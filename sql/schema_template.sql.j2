-- {{ schema_type|title }} Schema for Stock ETL Pipeline - UNIFIED ID DESIGN
-- PostgreSQL 17+ compatible with timezone and epoch support
-- Template: schema_template.sql.j2
-- IMPROVEMENT: Single instrument ID across all tables (base_instruments.id is the only instrument identifier)

-- Drop and recreate schema for clean state
DROP SCHEMA IF EXISTS {{ schema_name }} CASCADE;
CREATE SCHEMA IF NOT EXISTS {{ schema_name }};
SET search_path TO {{ schema_name }}, public;

-- Create enums
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'instrument_type' AND typnamespace = (SELECT oid FROM pg_namespace WHERE nspname = '{{ schema_name }}')) THEN
        CREATE TYPE {{ schema_name }}.instrument_type AS ENUM ('stock', 'index', 'etf', 'bond', 'future', 'option');
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'exchange_code' AND typnamespace = (SELECT oid FROM pg_namespace WHERE nspname = '{{ schema_name }}')) THEN
        CREATE TYPE {{ schema_name }}.exchange_code AS ENUM ('WSE', 'NewConnect', 'Catalyst', 'BondSpot', 'NYSE', 'NASDAQ', 'LSE');
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'job_status' AND typnamespace = (SELECT oid FROM pg_namespace WHERE nspname = '{{ schema_name }}')) THEN
        CREATE TYPE {{ schema_name }}.job_status AS ENUM ('pending', 'running', 'completed', 'failed', 'cancelled', 'retrying');
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'severity_level' AND typnamespace = (SELECT oid FROM pg_namespace WHERE nspname = '{{ schema_name }}')) THEN
        CREATE TYPE {{ schema_name }}.severity_level AS ENUM ('info', 'warning', 'error', 'critical');
    END IF;
END $$;

-- Countries table
CREATE TABLE IF NOT EXISTS countries (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,
    iso_code VARCHAR(3) NOT NULL UNIQUE,
    currency_code VARCHAR(3) NOT NULL,
    timezone VARCHAR(50) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_at_epoch BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP)::BIGINT
);

-- Exchanges table
CREATE TABLE IF NOT EXISTS exchanges (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    mic_code VARCHAR(4) NOT NULL UNIQUE,
    country_id INTEGER NOT NULL REFERENCES countries(id),
    timezone VARCHAR(50) NOT NULL,
    market_open TIME NOT NULL,
    market_close TIME NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_at_epoch BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP)::BIGINT
);

-- Sectors table
CREATE TABLE IF NOT EXISTS sectors (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,
    code VARCHAR(10) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_at_epoch BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP)::BIGINT
);

-- UNIFIED ID DESIGN: Base instruments table - SINGLE SOURCE OF TRUTH for all instrument IDs
CREATE TABLE IF NOT EXISTS base_instruments (
    id SERIAL PRIMARY KEY,  -- THIS IS THE ONLY INSTRUMENT ID IN THE ENTIRE SYSTEM
    symbol VARCHAR(50) NOT NULL,
    name VARCHAR(255) NOT NULL,
    instrument_type {{ schema_name }}.instrument_type NOT NULL,
    exchange_id INTEGER NOT NULL REFERENCES exchanges(id),
    sector_id INTEGER REFERENCES sectors(id),
    currency VARCHAR(10) NOT NULL DEFAULT 'USD',
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    first_trading_date DATE,
    last_trading_date DATE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_at_epoch BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP)::BIGINT,
    
    CONSTRAINT unique_symbol_exchange UNIQUE (symbol, exchange_id)
);

-- SIMPLIFIED: Stocks table - NO separate ID, uses base_instruments.id as PRIMARY KEY
CREATE TABLE IF NOT EXISTS stocks (
    instrument_id INTEGER PRIMARY KEY REFERENCES base_instruments(id) ON DELETE CASCADE,
    company_name VARCHAR(255) NOT NULL,
    sector_id INTEGER REFERENCES sectors(id),
    market_cap BIGINT,
    shares_outstanding BIGINT,
    dividend_yield DECIMAL(5,4),
    pe_ratio DECIMAL(8,2),
    book_value DECIMAL(8,2),
    stock_type VARCHAR(10) NOT NULL DEFAULT 'common',
    
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_at_epoch BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP)::BIGINT,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- SIMPLIFIED: Indices table - NO separate ID, uses base_instruments.id as PRIMARY KEY
CREATE TABLE IF NOT EXISTS indices (
    instrument_id INTEGER PRIMARY KEY REFERENCES base_instruments(id) ON DELETE CASCADE,
    methodology VARCHAR(100) NOT NULL DEFAULT 'market_cap_weighted',
    base_value DECIMAL(15,6) NOT NULL,
    base_date DATE NOT NULL,
    constituent_count INTEGER,
    calculation_frequency VARCHAR(20) NOT NULL DEFAULT 'real_time',
    index_family VARCHAR(100),
    
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_at_epoch BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP)::BIGINT,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- UNIFIED ID: Stock prices - stock_id points DIRECTLY to base_instruments.id (no intermediate stocks.id)
CREATE TABLE IF NOT EXISTS stock_prices (
    id BIGSERIAL PRIMARY KEY,
    stock_id INTEGER NOT NULL REFERENCES base_instruments(id) ON DELETE CASCADE,  -- DIRECT reference to base_instruments.id
    trading_date_local DATE NOT NULL,
    trading_date_utc DATE NOT NULL,
    trading_date_epoch BIGINT NOT NULL,
    trading_datetime_utc TIMESTAMP WITH TIME ZONE,
    trading_datetime_epoch BIGINT,
    open_price DECIMAL(15,6) NOT NULL,
    high_price DECIMAL(15,6) NOT NULL,
    low_price DECIMAL(15,6) NOT NULL,
    close_price DECIMAL(15,6) NOT NULL,
    volume BIGINT NOT NULL DEFAULT 0,
    adjusted_close DECIMAL(15,6),
    split_factor DECIMAL(10,6) NOT NULL DEFAULT 1.0,
    dividend_amount DECIMAL(10,6) NOT NULL DEFAULT 0.0,
    data_source VARCHAR(50) NOT NULL DEFAULT 'manual',
    raw_data_hash CHAR(64),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_at_epoch BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP)::BIGINT,
    
    CONSTRAINT unique_stock_date UNIQUE (stock_id, trading_date_local),
    CONSTRAINT positive_prices CHECK (open_price >= 0 AND high_price >= 0 AND low_price >= 0 AND close_price >= 0),
    CONSTRAINT ohlc_consistency CHECK (high_price >= open_price AND high_price >= close_price AND high_price >= low_price AND open_price >= low_price AND close_price >= low_price)
);

-- UNIFIED ID: Index prices - index_id points DIRECTLY to base_instruments.id (no intermediate indices.id)
CREATE TABLE IF NOT EXISTS index_prices (
    id BIGSERIAL PRIMARY KEY,
    index_id INTEGER NOT NULL REFERENCES base_instruments(id) ON DELETE CASCADE,  -- DIRECT reference to base_instruments.id
    trading_date_local DATE NOT NULL,
    trading_date_utc DATE NOT NULL,
    trading_date_epoch BIGINT NOT NULL,
    trading_datetime_utc TIMESTAMP WITH TIME ZONE,
    trading_datetime_epoch BIGINT,
    open_value DECIMAL(15,6) NOT NULL,
    high_value DECIMAL(15,6) NOT NULL,
    low_value DECIMAL(15,6) NOT NULL,
    close_value DECIMAL(15,6) NOT NULL,
    trading_volume BIGINT NOT NULL DEFAULT 0,
    total_market_cap BIGINT,
    constituents_traded INTEGER,
    data_source VARCHAR(50) NOT NULL DEFAULT 'manual',
    raw_data_hash CHAR(64),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_at_epoch BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP)::BIGINT,
    
    CONSTRAINT unique_index_date UNIQUE (index_id, trading_date_local),
    CONSTRAINT positive_values CHECK (open_value >= 0 AND high_value >= 0 AND low_value >= 0 AND close_value >= 0)
);

-- ETL jobs table (unchanged - tracking remains the same)
CREATE TABLE IF NOT EXISTS etl_jobs (
    id BIGSERIAL PRIMARY KEY,
    job_name VARCHAR(100) NOT NULL,
    job_type VARCHAR(50) NOT NULL,
    target_instrument_type {{ schema_name }}.instrument_type,
    status {{ schema_name }}.job_status NOT NULL DEFAULT 'pending',
    started_at TIMESTAMP WITH TIME ZONE NOT NULL,
    started_at_epoch BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP)::BIGINT,
    completed_at TIMESTAMP WITH TIME ZONE,
    completed_at_epoch BIGINT,
    duration_seconds INTEGER,
    records_processed INTEGER NOT NULL DEFAULT 0,
    records_inserted INTEGER NOT NULL DEFAULT 0,
    records_updated INTEGER NOT NULL DEFAULT 0,
    records_failed INTEGER NOT NULL DEFAULT 0,
    error_message TEXT,
    retry_count INTEGER NOT NULL DEFAULT 0,
    max_retries INTEGER NOT NULL DEFAULT 3,
    source_files TEXT[], -- Array of source files processed
    target_date_range_start DATE,
    target_date_range_end DATE,
    airflow_dag_id VARCHAR(100),
    airflow_task_id VARCHAR(100),
    airflow_run_id VARCHAR(100),
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_at_epoch BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP)::BIGINT
);

-- ETL job details table (updated to use unified IDs)
CREATE TABLE IF NOT EXISTS etl_job_details (
    id BIGSERIAL PRIMARY KEY,
    job_id BIGINT NOT NULL REFERENCES etl_jobs(id) ON DELETE CASCADE,
    instrument_id INTEGER REFERENCES base_instruments(id),  -- DIRECT reference to base_instruments.id
    symbol VARCHAR(50) NOT NULL,
    instrument_type {{ schema_name }}.instrument_type NOT NULL,
    processing_order INTEGER NOT NULL,
    status {{ schema_name }}.job_status NOT NULL DEFAULT 'pending',
    started_at TIMESTAMP WITH TIME ZONE,
    started_at_epoch BIGINT DEFAULT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP)::BIGINT,
    completed_at TIMESTAMP WITH TIME ZONE,
    completed_at_epoch BIGINT,
    duration_milliseconds INTEGER,
    records_processed INTEGER NOT NULL DEFAULT 0,
    records_inserted INTEGER NOT NULL DEFAULT 0,
    records_updated INTEGER NOT NULL DEFAULT 0,
    records_failed INTEGER NOT NULL DEFAULT 0,
    target_date DATE NOT NULL,
    target_date_epoch BIGINT NOT NULL,
    error_message TEXT,
    retry_count INTEGER NOT NULL DEFAULT 0,
    data_source VARCHAR(50) NOT NULL,
    raw_data_size_bytes INTEGER,
    validation_passed BOOLEAN,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_at_epoch BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP)::BIGINT
);

-- Data quality metrics table (updated to use unified IDs)
CREATE TABLE IF NOT EXISTS data_quality_metrics (
    id BIGSERIAL PRIMARY KEY,
    job_id BIGINT REFERENCES etl_jobs(id) ON DELETE CASCADE,
    instrument_id INTEGER REFERENCES base_instruments(id),  -- DIRECT reference to base_instruments.id
    metric_name VARCHAR(100) NOT NULL,
    metric_value DECIMAL(20,6) NOT NULL,
    is_valid BOOLEAN NOT NULL,
    severity {{ schema_name }}.severity_level NOT NULL DEFAULT 'info',
    threshold_value DECIMAL(20,6),
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_at_epoch BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP)::BIGINT
);

{% if schema_type == 'development' %}
-- Reference data for development
INSERT INTO countries (name, iso_code, currency_code, timezone) VALUES 
('Poland', 'POL', 'PLN', 'Europe/Warsaw'),
('United States', 'USA', 'USD', 'America/New_York'),
('Germany', 'DEU', 'EUR', 'Europe/Berlin')
ON CONFLICT (iso_code) DO NOTHING;

INSERT INTO exchanges (name, mic_code, country_id, timezone, market_open, market_close, is_active) VALUES 
('Warsaw Stock Exchange', 'XWAR', (SELECT id FROM countries WHERE iso_code = 'POL'), 'Europe/Warsaw', '09:00:00', '17:00:00', TRUE),
('New York Stock Exchange', 'XNYS', (SELECT id FROM countries WHERE iso_code = 'USA'), 'America/New_York', '09:30:00', '16:00:00', TRUE),
('NASDAQ', 'XNAS', (SELECT id FROM countries WHERE iso_code = 'USA'), 'America/New_York', '09:30:00', '16:00:00', TRUE)
ON CONFLICT (mic_code) DO NOTHING;

INSERT INTO sectors (name, code, description) VALUES 
('Technology', 'TECH', 'Technology companies'),
('Financial Services', 'FINS', 'Banks, insurance, financial services'),
('Energy', 'ENRG', 'Oil, gas, renewable energy'),
('Healthcare', 'HLTH', 'Pharmaceuticals, medical devices'),
('Consumer Goods', 'CONS', 'Retail, consumer products'),
('Industrials', 'INDU', 'Manufacturing, construction'),
('Materials', 'MATL', 'Mining, chemicals, materials'),
('Utilities', 'UTIL', 'Electric, gas, water utilities'),
('Real Estate', 'REAL', 'Real estate investment and services'),
('Telecommunications', 'TCOM', 'Telecom services and equipment')
ON CONFLICT (code) DO NOTHING;

-- Sample instruments for development (using UNIFIED ID design)
INSERT INTO base_instruments (symbol, name, instrument_type, exchange_id, sector_id, currency, is_active, first_trading_date) VALUES 
('XTB', 'X-Trade Brokers Dom Maklerski S.A.', 'stock', (SELECT id FROM exchanges WHERE mic_code = 'XWAR'), (SELECT id FROM sectors WHERE code = 'FINS'), 'PLN', TRUE, '2016-05-30'),
('PKN', 'Polski Koncern Naftowy ORLEN S.A.', 'stock', (SELECT id FROM exchanges WHERE mic_code = 'XWAR'), (SELECT id FROM sectors WHERE code = 'ENRG'), 'PLN', TRUE, '1999-11-17'),
('WIG', 'WIG Index', 'index', (SELECT id FROM exchanges WHERE mic_code = 'XWAR'), NULL, 'PLN', TRUE, '1991-04-16'),
('WIG20', 'WIG20 Index', 'index', (SELECT id FROM exchanges WHERE mic_code = 'XWAR'), NULL, 'PLN', TRUE, '1994-04-18')
ON CONFLICT (symbol, exchange_id) DO NOTHING;

-- Create stocks entries (using base_instruments.id directly)
INSERT INTO stocks (instrument_id, company_name, sector_id, stock_type)
SELECT bi.id, bi.name, bi.sector_id, 'common'
FROM base_instruments bi
WHERE bi.instrument_type = 'stock'
ON CONFLICT (instrument_id) DO NOTHING;

-- Create indices entries (using base_instruments.id directly)  
INSERT INTO indices (instrument_id, methodology, base_value, base_date, index_family)
SELECT bi.id, 'market_cap_weighted', 1000.0, '1991-04-16', 'WSE'
FROM base_instruments bi
WHERE bi.instrument_type = 'index'
ON CONFLICT (instrument_id) DO NOTHING;

-- Sample stock price data for development (UNIFIED ID: stock_id = base_instruments.id)
INSERT INTO stock_prices (stock_id, trading_date_local, trading_date_utc, trading_date_epoch, open_price, high_price, low_price, close_price, volume, data_source)
WITH price_data AS (
  SELECT 
    bi.id as stock_id,
    CURRENT_DATE - (i || ' days')::interval as trading_date,
    -- Generate base open and close prices
    (50.0 + (RANDOM() * 10))::DECIMAL(15,6) as open_price,
    (50.0 + (RANDOM() * 10))::DECIMAL(15,6) as close_price,
    i
  FROM base_instruments bi
  CROSS JOIN generate_series(1, 30) i
  WHERE bi.instrument_type = 'stock'
)
SELECT 
    stock_id,
    trading_date,
    trading_date,
    EXTRACT(EPOCH FROM trading_date)::BIGINT,
    open_price,
    -- High = max(open, close) + premium (satisfies constraint)
    GREATEST(open_price, close_price) + (RANDOM() * 2 + 0.5)::DECIMAL(15,6),
    -- Low = min(open, close) - discount (satisfies constraint)
    LEAST(open_price, close_price) - (RANDOM() * 2 + 0.5)::DECIMAL(15,6),
    close_price,
    (1000 + (RANDOM() * 5000))::BIGINT,
    'sample_data'
FROM price_data
ON CONFLICT (stock_id, trading_date_local) DO NOTHING;

-- Sample index price data for development (UNIFIED ID: index_id = base_instruments.id)
INSERT INTO index_prices (index_id, trading_date_local, trading_date_utc, trading_date_epoch, open_value, high_value, low_value, close_value, trading_volume, data_source)
WITH index_data AS (
  SELECT 
    bi.id as index_id,
    CURRENT_DATE - (i || ' days')::interval as trading_date,
    -- Generate base open and close values
    (50000.0 + (RANDOM() * 1000))::DECIMAL(15,6) as open_value,
    (50000.0 + (RANDOM() * 1000))::DECIMAL(15,6) as close_value,
    i
  FROM base_instruments bi
  CROSS JOIN generate_series(1, 30) i  
  WHERE bi.instrument_type = 'index'
)
SELECT 
    index_id,
    trading_date,
    trading_date,
    EXTRACT(EPOCH FROM trading_date)::BIGINT,
    open_value,
    -- High = max(open, close) + premium (satisfies constraint)
    GREATEST(open_value, close_value) + (RANDOM() * 200 + 50)::DECIMAL(15,6),
    -- Low = min(open, close) - discount (satisfies constraint)
    LEAST(open_value, close_value) - (RANDOM() * 200 + 25)::DECIMAL(15,6),
    close_value,
    (10000 + (RANDOM() * 50000))::BIGINT,
    'sample_data'
FROM index_data
ON CONFLICT (index_id, trading_date_local) DO NOTHING;
{% endif %}

-- Create helper function for epoch calculations
CREATE OR REPLACE FUNCTION calculate_date_epoch(input_date DATE, timezone_name TEXT DEFAULT 'UTC')
RETURNS BIGINT AS $$
BEGIN
    RETURN EXTRACT(EPOCH FROM (input_date AT TIME ZONE timezone_name))::BIGINT;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Performance optimization indexes (UNIFIED ID design)
DO $$
BEGIN
    -- Base instruments indexes
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_base_instruments_symbol ON base_instruments(symbol)';
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_base_instruments_type ON base_instruments(instrument_type)';
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_base_instruments_exchange ON base_instruments(exchange_id)';
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_base_instruments_active ON base_instruments(is_active)';
    
    -- Stock prices indexes (using base_instruments.id directly)
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_stock_prices_stock_id ON stock_prices(stock_id)';
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_stock_prices_date ON stock_prices(trading_date_local)';
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_stock_prices_stock_date ON stock_prices(stock_id, trading_date_local DESC)';
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_stock_prices_date_epoch ON stock_prices(trading_date_epoch)';
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_stock_prices_source ON stock_prices(data_source)';
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_stock_prices_hash ON stock_prices(raw_data_hash)';
    
    -- Index prices indexes (using base_instruments.id directly)
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_index_prices_index_id ON index_prices(index_id)';
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_index_prices_date ON index_prices(trading_date_local)';
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_index_prices_index_date ON index_prices(index_id, trading_date_local DESC)';
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_index_prices_date_epoch ON index_prices(trading_date_epoch)';
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_index_prices_source ON index_prices(data_source)';
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_index_prices_hash ON index_prices(raw_data_hash)';
    
    -- ETL tracking indexes
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_etl_jobs_status ON etl_jobs(status)';
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_etl_jobs_started_at ON etl_jobs(started_at)';
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_etl_jobs_job_type ON etl_jobs(job_type)';
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_etl_job_details_job_id ON etl_job_details(job_id)';
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_etl_job_details_instrument_id ON etl_job_details(instrument_id)';
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_etl_job_details_target_date ON etl_job_details(target_date)';
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_data_quality_metrics_instrument_id ON data_quality_metrics(instrument_id)';
    EXECUTE 'CREATE INDEX IF NOT EXISTS idx_data_quality_metrics_severity ON data_quality_metrics(severity)';
END $$;